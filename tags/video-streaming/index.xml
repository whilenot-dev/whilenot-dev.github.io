<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>video streaming on wh!le / blog</title><link>https://blog.whilenot.dev/tags/video-streaming/</link><description>Recent content in video streaming on wh!le / blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 10 Apr 2022 14:29:10 +0200</lastBuildDate><atom:link href="https://blog.whilenot.dev/tags/video-streaming/index.xml" rel="self" type="application/rss+xml"/><item><title>Cool Bugs VS Shitty Bugs, Part 1: Cool Bugs</title><link>https://blog.whilenot.dev/posts/cool-bugs-vs-shitty-bugs-part-1/</link><pubDate>Sun, 10 Apr 2022 14:29:10 +0200</pubDate><guid>https://blog.whilenot.dev/posts/cool-bugs-vs-shitty-bugs-part-1/</guid><description>Steaming video via Motion JPEG and counting established TCP sockets Recently I had to debug a problem in an SPA regarding Motion JPEG streams for one of my clients. I found this journey so interesting that I wanted to share it as my first blog post.
The post should give the reader an intro on what it means nowadays to do frontend engineering. What follows is a post that touches on MJPEG streams, HTTP pushes, TCP sockets and their observability.</description><content>&lt;h1 id="steaming-video-via-motion-jpeg-and-counting-established-tcp-sockets">Steaming video via Motion JPEG and counting established TCP sockets&lt;/h1>
&lt;p>Recently I had to debug a problem in an SPA regarding Motion JPEG streams for one of my clients. I found this journey so interesting that I wanted to share it as my first blog post.&lt;/p>
&lt;p>The post should give the reader an intro on what it means nowadays to do frontend engineering. What follows is a post that touches on &lt;em>MJPEG streams&lt;/em>, &lt;em>HTTP pushes&lt;/em>, &lt;em>TCP sockets&lt;/em> and &lt;em>their observability&lt;/em>. What I assumed to be a bug in either application code or even the &lt;em>react&lt;/em> library, just turned out to surprise me, and I think it could surprise others as well.&lt;/p>
&lt;p>So let&amp;rsquo;s step through it together and let me start by outlining the system of my client.&lt;/p>
&lt;h2 id="describing-the-system">Describing the system&lt;/h2>
&lt;p>The system, as currently present in a product of my client, contains among other services a statically served SPA (written with &lt;a href="https://reactjs.org/">&lt;em>react&lt;/em>&lt;/a>) and a video stream server (written with &lt;a href="https://www.ros.org/">&lt;em>ROS&lt;/em>&lt;/a> in &lt;em>C++&lt;/em>/&lt;em>Python&lt;/em>).&lt;/p>
&lt;p>The stream server offers its data to the SPA in the &lt;a href="https://en.wikipedia.org/wiki/Motion_JPEG">Motion JPEG (&lt;em>MJPEG&lt;/em>)&lt;/a> format. MJPEG is an rather archaic approach, but still does its job well enough and, among other things, hides all video interaction from the UI.&lt;/p>
&lt;p>In the shipped product both servers run on different hosts, but for this post let&amp;rsquo;s assume the SPA is statically served via &lt;code>:8000&lt;/code> and the MJPEG server is serving its video stream via &lt;code>:8001&lt;/code>, both on the same host &lt;code>0.0.0.0&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://blog.whilenot.dev/images/cool-bugs-vs-shitty-bugs-part-1/system_overview.png" alt="system_overview.png" title="System overview">&lt;/p>
&lt;p>The users of this product are able to access the SPA via a Chromium-based browser and can then see the video stream in the center of the page. A reponsive behavior is implemented as well, but apparently the system didn&amp;rsquo;t work as expected&amp;hellip;&lt;/p>
&lt;h2 id="a-bug-in-todo">A bug in ToDo&lt;/h2>
&lt;p>At the beginning of the week I found a new bug-ticket and its description contained something like the following:&lt;/p>
&lt;blockquote>
&lt;p>By changing the size of the visible video stream in the UI more than 5 times times, eg. by resizing the browser window, the video stream gets lost and the image just shows a blank background.&lt;/p>
&lt;/blockquote>
&lt;p>With the description being elaborate enough, I started up the two affected servers:&lt;/p>
&lt;ul>
&lt;li>the one serving the &lt;em>react&lt;/em> SPA&lt;/li>
&lt;li>and the one MJPEG stream server&lt;/li>
&lt;/ul>
&lt;p>&amp;hellip;and assumed that the video server got exhausted. I could imediately confirming my assumption as its logs contained entries like the following:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">[mjpeg_server] WARN: to many open streams (6/5)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By doing the resizing with the &lt;em>DevTools&lt;/em> on the sidebar of the browser window, and by having the network tab open with the filter set to &lt;code>Img&lt;/code> (assuming &lt;em>Brave&lt;/em>), I can observe that there are still data pushed from the MJPEG server, even though the stream got presumably &amp;ldquo;lost&amp;rdquo;. Even more interesting, &lt;strong>all URIs that were ever used to request a MJPEG stream since session start were still receiving server pushes&lt;/strong> that contained streaming data from the server.&lt;/p>
&lt;p>So it looks like each resize event that alters the URI for a new stream request doesn&amp;rsquo;t properly cleanup the streams that were requested previously. With each new such event the browser would just request another distinct stream from the MJPEG server and stack them up while keeping the older ones alife.&lt;/p>
&lt;p>Let&amp;rsquo;s have a look at the source code to get some insights and to compare the observed behavior with the current implementation.&lt;/p>
&lt;h2 id="some-of-the-systems-current-implementation">Some of the systems current implementation&lt;/h2>
&lt;p>I just want to outline the concept here before I go on to create an isolated playground for the reader to try it out themselves.&lt;/p>
&lt;h3 id="react-spa">React SPA&lt;/h3>
&lt;p>The &lt;em>react&lt;/em> component for the stream viewer looked something like the following:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#75715e">// stream.tsx
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">StreamProps&lt;/span> {
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * visible height of the wrapping element in px
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">height&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>;
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * visible width of the wrapping element in px
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">width&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span>;
}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">Stream&lt;/span>(&lt;span style="color:#a6e22e">props&lt;/span>: &lt;span style="color:#66d9ef">StreamProps&lt;/span>) {
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * choose between two possible streams based on the max visible size
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">resolution&lt;/span> &lt;span style="color:#f92672">=&lt;/span>
&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">height&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1080&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">width&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1920&lt;/span>
&lt;span style="color:#f92672">?&lt;/span> {
&lt;span style="color:#a6e22e">height&lt;/span>: &lt;span style="color:#66d9ef">1080&lt;/span>,
&lt;span style="color:#a6e22e">width&lt;/span>: &lt;span style="color:#66d9ef">1920&lt;/span>,
}
&lt;span style="color:#f92672">:&lt;/span> {
&lt;span style="color:#a6e22e">height&lt;/span>: &lt;span style="color:#66d9ef">720&lt;/span>,
&lt;span style="color:#a6e22e">width&lt;/span>: &lt;span style="color:#66d9ef">1280&lt;/span>,
};
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`//0.0.0.0:8001/?resolution=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">resolution&lt;/span>.&lt;span style="color:#a6e22e">width&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">x&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">resolution&lt;/span>.&lt;span style="color:#a6e22e">height&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &amp;lt;&lt;span style="color:#f92672">img&lt;/span> &lt;span style="color:#a6e22e">alt&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading stream...&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">src&lt;/span>} {&lt;span style="color:#a6e22e">...props&lt;/span>} /&amp;gt;;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A simple functional component in &lt;em>TypeScript&lt;/em> that, depending on the available size, chooses a stream resolution to be either &lt;code>1080p&lt;/code> or &lt;code>720p&lt;/code>; adaptive streaming in a manual fashion, presumably to safe some bandwidth and lower the computing resources on the MJPEG server. Its parent component did guarantee the aspect ratio and the handling of the &lt;code>resize&lt;/code> event accordingly.&lt;/p>
&lt;p>But, as I just observed in the reproduction step above, even though the &lt;code>resize&lt;/code> event causes a correct re-render of the &lt;code>Stream&lt;/code>-component, the unmounted components were still receiving HTTP pushes from previously used streams. &lt;em>react&lt;/em> somehow didn&amp;rsquo;t close the stream in the unmount cycle of the component as I would expect from this implementation.&lt;/p>
&lt;p>&amp;hellip;so, a bug in &lt;em>react&lt;/em>?&lt;/p>
&lt;h3 id="mjpeg-server">MJPEG Server&lt;/h3>
&lt;p>The MJPEG video stream server is implemented in &lt;em>C++&lt;/em> and for proprietary reasons I just want to outline the implemeted behavior here with a short description. Later on I&amp;rsquo;ll provide some code, so we can create a MJPEG server the FOSS way.&lt;/p>
&lt;p>Internally the streaming server gets its images by subscribing to a &lt;a href="http://wiki.ros.org/Topics">&lt;em>ROS&lt;/em> Topic&lt;/a>. It receives frames in a certain frequency, waits for a browser client to request a stream and then goes on with the encoding of a new MJPEG stream for each unique URI.&lt;/p>
&lt;p>The browser client is in charge of some stream options via the query: &lt;em>resolution&lt;/em>, &lt;em>framerate&lt;/em>, &lt;em>quality&lt;/em> etc. &lt;code>/?resolution=1920x1080&lt;/code> and &lt;code>/?resolution=1280x720&lt;/code> will produce two distinct MJPEG video streams with different resolutions, just as we&amp;rsquo;ve seen in the &lt;em>react&lt;/em> &lt;code>Stream&lt;/code>-component above. And, like present in the server logs, the maximum number of MJPEG streams is limited to 5 streams for a single server. Each client that requests a stream with an identical URI will consume the same MJPEG stream.&lt;/p>
&lt;p>There are some comments in the source code mentioning:&lt;/p>
&lt;blockquote>
&lt;p>Every created stream will be garbage collected after there is no application consuming it anymore and some timeout emitted after its last consumption.&lt;/p>
&lt;/blockquote>
&lt;p>To isolate the problem (and to provide some usable example code for the readers of this post) let me create an environment as vanilla as possible&amp;hellip;&lt;/p>
&lt;h2 id="an-isolated-environment-as-playground">An isolated environment as playground&lt;/h2>
&lt;p>For reproducibility purposes I want to provide some simplified versions of the two servers mentioned above. I need to create one server that provides an endless MJPEG video stream via HTTP and one that serves a simple SPA in order to request this MJPEG stream via a &lt;code>src&lt;/code> attribute in an HTML &lt;code>img&lt;/code> element.&lt;/p>
&lt;p>&lt;strong>tl;dr&lt;/strong> you can clone the mentioned files &lt;a href="https://github.com/whilenot-dev/cool-bugs-vs-shitty-bugs-part-1">here&lt;/a>.&lt;/p>
&lt;h3 id="a-simple-mjpeg-server">A simple MJPEG server&lt;/h3>
&lt;p>The following packages are needed to launch the MJPEG server successfully (assuming &lt;em>Fedora&lt;/em>):&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Netcat">&lt;em>netcat&lt;/em>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gstreamer.freedesktop.org">&lt;em>gstreamer1&lt;/em>&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gstreamer.freedesktop.org">&lt;em>gstreamer1-plugins-good&lt;/em>&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>The way MJPEG is streamed via HTTP is with the &lt;a href="https://en.wikipedia.org/wiki/MIME#x-mixed-replace">&lt;code>multipart/x-mixed-replace&lt;/code> MIME type&lt;/a>. I will cover the &lt;em>why&lt;/em>&amp;rsquo;s and &lt;em>how&lt;/em>&amp;rsquo;s later on in a section below when I go a bit into detail of the involved specs. But for now, let me just echo an HTTP MJPEG stream to &lt;em>STDOUT&lt;/em> first.&lt;/p>
&lt;p>I use &lt;code>gstreamer&lt;/code>&amp;rsquo;s &lt;code>gst-launch&lt;/code> cli to create a simple MJPEG media pipeline and, like in the &lt;em>Netscape&lt;/em> example in the section below about specs, I prepend this load with some &lt;code>echo&lt;/code>ing for the initial &lt;code>multipart&lt;/code> HTTP-header:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># start-stream.sh&lt;/span>
&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
BOUNDARY_GST_PREFIX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span> &lt;span style="color:#75715e"># the gstreamer plugin seems to have a prefix for the boundary&lt;/span>
BOUNDARY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-ThisRandomString---&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># multipart header&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;HTTP/1.0 200&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;Content-type: multipart/x-mixed-replace;boundary=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>BOUNDARY_GST_PREFIX&lt;span style="color:#e6db74">}${&lt;/span>BOUNDARY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># multipart body parts&lt;/span>
gst-launch-1.0 -q &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> videotestsrc is-live&lt;span style="color:#f92672">=&lt;/span>true pattern&lt;span style="color:#f92672">=&lt;/span>ball motion&lt;span style="color:#f92672">=&lt;/span>sweep ! &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> videorate rate&lt;span style="color:#f92672">=&lt;/span>0.04 ! &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> video/x-raw,width&lt;span style="color:#f92672">=&lt;/span>640,height&lt;span style="color:#f92672">=&lt;/span>480,framerate&lt;span style="color:#f92672">=&lt;/span>60/1 ! &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> jpegenc quality&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span> ! &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> multipartmux boundary&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>BOUNDARY&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> ! &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span> filesink append&lt;span style="color:#f92672">=&lt;/span>true location&lt;span style="color:#f92672">=&lt;/span>/dev/stdout &lt;span style="color:#75715e"># the fdsink plugin didn&amp;#39;t provide the needed `append` property to include the echoed header&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I&amp;rsquo;m picking the sweeping ball test video source of gstreamer as my infinite stream here. Executing this scripts in the terminal will for the mostly just output some gibberish (JPEG binary data), but you can see that the HTTP header are there as well.&lt;/p>
&lt;p>Now with a proper terminal output ready I make use of &lt;code>netcat&lt;/code> (&lt;code>nc&lt;/code>) in listen mode to provide this output as an actual HTTP response from an server:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># serve.sh&lt;/span>
&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
DIR&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span> dirname &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span> realpath &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$0&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">)&lt;/span>
nc -l -k -p &lt;span style="color:#ae81ff">8001&lt;/span> -c &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>DIR&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/start-stream.sh&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So with a directory structure like the following:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">.
├── serve.sh
└── start-stream.sh
&lt;span style="color:#ae81ff">0&lt;/span> directories, &lt;span style="color:#ae81ff">2&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;I can start my hacky MJPEG server with:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./serve.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;to listen for HTTP requests on &lt;code>0.0.0.0:8001&lt;/code> and respond with a MJPEG video stream.&lt;/p>
&lt;p>&lt;img src="https://blog.whilenot.dev/images/cool-bugs-vs-shitty-bugs-part-1/playground_mjpeg.png" alt="playground_mjpeg.png" title="Playground of MJPEG Stream">&lt;/p>
&lt;p>Now to the SPA&amp;hellip;&lt;/p>
&lt;h3 id="a-simple-vanilla-spa">A simple vanilla SPA&lt;/h3>
&lt;p>For the SPA I also want to stay vanilla and try to work without any 3rd party library involvement (eg. &lt;em>react&lt;/em>):&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&lt;span style="color:#75715e">&amp;lt;!-- index.html --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#f92672">html&lt;/span> &lt;span style="color:#a6e22e">lang&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;en&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">charset&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span> /&amp;gt;
&amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">http-equiv&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X-UA-Compatible&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;IE=edge&amp;#34;&lt;/span> /&amp;gt;
&amp;lt;&lt;span style="color:#f92672">meta&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;viewport&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">content&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span> /&amp;gt;
&amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;MJPEG Stream&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/main.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// main.js
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
document.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;DOMContentLoaded&amp;#34;&lt;/span>, () =&amp;gt; {
&lt;span style="color:#a6e22e">main&lt;/span>();
});
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#75715e">// just a single mount-/unmount-cycle
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">addStream&lt;/span>();
window.&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">removeStream&lt;/span>, &lt;span style="color:#ae81ff">10000&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">addStream&lt;/span>() {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;img&amp;#34;&lt;/span>);
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;stream&amp;#34;&lt;/span>);
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;alt&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;loading stream...&amp;#34;&lt;/span>);
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;http://0.0.0.0:8001/&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// ref to the netcat MJPEG server above
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;height&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;480&amp;#34;&lt;/span>);
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;width&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;640&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;load&amp;#34;&lt;/span>, () =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`images loaded: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#f92672">++&lt;/span>&lt;span style="color:#a6e22e">count&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
});
document.&lt;span style="color:#a6e22e">body&lt;/span>.&lt;span style="color:#a6e22e">appendChild&lt;/span>(&lt;span style="color:#a6e22e">img&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">removeStream&lt;/span>() {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stream&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">img&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Instead of removing the HTML element from the DOM with &lt;em>react&lt;/em> through a conditional &lt;code>resize&lt;/code> event, I just use a timeout of 10s. This will provide - to my surprise - a setup that is already sufficient enough to recreate the observed bug, as I will now show.&lt;/p>
&lt;p>I can simply serve those files with the static file server of my choice:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># serve.sh&lt;/span>
&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
python -m http.server &lt;span style="color:#ae81ff">8000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;so with a directory structure like the following:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">.
├── index.html
├── main.js
└── serve.sh
&lt;span style="color:#ae81ff">0&lt;/span> directories, &lt;span style="color:#ae81ff">3&lt;/span> files
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;I can start the SPA server with:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./serve.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;and can consum the MJPEG stream with my vanilla SPA on &lt;code>0.0.0.0:8000&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://blog.whilenot.dev/images/cool-bugs-vs-shitty-bugs-part-1/playground_spa.png" alt="playground_spa.png" title="Playground of SPA">&lt;/p>
&lt;p>Let&amp;rsquo;s do some observations together!&lt;/p>
&lt;h2 id="observability">Observability&lt;/h2>
&lt;p>With the playground in place, let me observe the behavior of the loading MJPEG stream more closely.&lt;/p>
&lt;h3 id="playing-on-the-playground">Playing on the playground&lt;/h3>
&lt;p>The browser already gives us quite some information on the network activity, even before consultiung additional tools.&lt;/p>
&lt;p>With a visit on &lt;code>0.0.0.0:8000&lt;/code> the browser let&amp;rsquo;s us observe the following.&lt;/p>
&lt;p>On &lt;em>Brave&lt;/em>:&lt;/p>
&lt;ul>
&lt;li>the images of the stream get properly rendered without stutter for 10s&lt;/li>
&lt;li>the logs contain a single entry: &lt;code>images loaded: 1&lt;/code>&lt;/li>
&lt;li>the stream keeps loading in the background after the HTML &lt;code>img&lt;/code> element has been removed from the DOM!&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://blog.whilenot.dev/images/cool-bugs-vs-shitty-bugs-part-1/playground.gif" alt="playground.gif" title="Playground animated">&lt;/p>
&lt;p>On &lt;em>Firefox&lt;/em> (just for completeness):&lt;/p>
&lt;ul>
&lt;li>no image of the stream is shown (just an occasional single frame on my system, if I&amp;rsquo;m even lucky)&lt;/li>
&lt;li>there are quite some log entries á la &lt;code>images loaded: x&lt;/code>, seemingly for each multipart body part&lt;/li>
&lt;li>the stream also keeps loading in the background after the HTML &lt;code>img&lt;/code> element has been removed from the DOM and it even keeps logging entries!&lt;/li>
&lt;/ul>
&lt;p>My client just puts its focus on Chromium based browsers with their product, but &lt;em>UH OH!&lt;/em> this difference in modern browser engines is worrysome. Why does the browser keep receiving data after the &lt;code>img&lt;/code> HTML element has been removed from the DOM in both cases?&lt;/p>
&lt;p>Let us observe the established TCP sockets for the MJPEG server on OS level.&lt;/p>
&lt;h3 id="making-established-tcp-sockets-visible">Making established TCP sockets visible&lt;/h3>
&lt;p>After feeling enlighted and motivated by &lt;em>Brendan Gregg&lt;/em>&amp;rsquo;s books &lt;em>BPF Performance Tools: Linux System and Application Observability&lt;/em> and &lt;em>Systems Performance: Enterprise and the Cloud&lt;/em>, let me get a list of all the established TCP sockets from the browser (source) to the MJPEG server (destination).&lt;/p>
&lt;p>With the servers running on my machine (with the scripts above) I can observe the established sockets for my destination with &lt;a href="https://www.man7.org/linux/man-pages/man8/ss.8.html">ss&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ss -HOna4t state established &lt;span style="color:#e6db74">&amp;#39;( dst = 127.0.0.1:8001 )&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">0 0 127.0.0.1:59590 127.0.0.1:8001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To observe any changes more easily I can &lt;a href="https://www.man7.org/linux/man-pages/man1/watch.1.html">watch&lt;/a> the output of the command also continuously as frequent as every 100ms.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch -n 0.1 &lt;span style="color:#e6db74">&amp;#34;ss -HOna4t state established &amp;#39;( dst = 127.0.0.1:8001 )&amp;#39;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">Every 0.1s: ss -HOna4t state established &amp;#39;( dst = 127.0.0.1:8001 )&amp;#39; dell-precision-5560.localdomain: Fri Apr 1 21:28:12 2022
0 0 127.0.0.1:59590 127.0.0.1:8001
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you don&amp;rsquo;t have &lt;code>ss&lt;/code> available on your system (maybe on MacOS?), &lt;a href="https://man7.org/linux/man-pages/man8/netstat.8.html">netstat&lt;/a> and &lt;a href="https://man7.org/linux/man-pages/man1/awk.1p.html">awk&lt;/a> provide similar capabilities.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch -n 0.1 &lt;span style="color:#e6db74">&amp;#34;netstat -4nt | awk &amp;#39;&amp;#34;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{ if ($5 == &amp;#34;127.0.0.1:8001&amp;#34; &amp;amp;&amp;amp; $6 == &amp;#34;ESTABLISHED&amp;#34;) print $0 }&amp;#39;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">Every 0.1s: netstat -4nt | awk &amp;#39;{ if ($5 == &amp;#34;127.0.0.1:8001&amp;#34; &amp;amp;&amp;amp; $... dell-precision-5560.localdomain: Fri Apr 1 21:29:28 2022
tcp 0 0 127.0.0.1:59592 127.0.0.1:8001 ESTABLISHED
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If I&amp;rsquo;m only interested in the &lt;strong>number&lt;/strong> of established sockets, I could narrow it down even further to a single numeric value. With one line per socket I could just count the number of lines.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch -n 0.1 &lt;span style="color:#e6db74">&amp;#34;ss -HOna4t state established &amp;#39;( dst = 127.0.0.1:8001 )&amp;#39; | wc -l&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;or with &lt;code>netstat&lt;/code> / &lt;code>awk&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ watch -n 0.1 &lt;span style="color:#e6db74">&amp;#34;netstat -4nt | awk &amp;#39;&amp;#34;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{ if ($5 == &amp;#34;127.0.0.1:8001&amp;#34; &amp;amp;&amp;amp; $6 == &amp;#34;ESTABLISHED&amp;#34;) print $0 }&amp;#39;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#39; | wc -l&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With one of those scripts running in the terminal I have the visible inidicator ready on OS level. I can clearly see that the established TCP socket doesn&amp;rsquo;t get closed after the HTML &lt;code>img&lt;/code> element has been removed from the DOM.&lt;/p>
&lt;p>We knew that one before by deriving it from the network tab in the &lt;em>DevTools&lt;/em>, but making it scriptable could give us some idea on how to test this behavior in an browser-independent automated way.&lt;/p>
&lt;p>Let me have a look at the specs. Maybe this behavior is according to the specs or they could give me another hint at least&amp;hellip;&lt;/p>
&lt;h2 id="gathering-some-insights-on-some-involved-specs">Gathering some insights on some involved specs&lt;/h2>
&lt;p>Let&amp;rsquo;s step from lowest to highest level: TCP sockets, MJPEG streaming via HTTP pushes, and the DOM elements.&lt;/p>
&lt;h3 id="tcp--rfc-793httpswwwrfc-editororgrfcrfc793">TCP / &lt;a href="https://www.rfc-editor.org/rfc/rfc793">RFC 793&lt;/a>&lt;/h3>
&lt;p>Did you ever had a look at the TCP RFC?&lt;/p>
&lt;p>What interests me in this case is the section about the different &lt;a href="https://www.rfc-editor.org/rfc/rfc793#section-3.2">states&lt;/a> a TCP socket can have:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt"> A connection progresses through a series of states during its
lifetime. The states are: LISTEN, SYN-SENT, SYN-RECEIVED,
ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
TIME-WAIT, and the fictional state CLOSED. CLOSED is fictional
because it represents the state when there is no TCB, and therefore,
no connection. Briefly the meanings of the states are:
LISTEN - represents waiting for a connection request from any remote
TCP and port.
SYN-SENT - represents waiting for a matching connection request
after having sent a connection request.
SYN-RECEIVED - represents waiting for a confirming connection
request acknowledgment after having both received and sent a
connection request.
ESTABLISHED - represents an open connection, data received can be
delivered to the user. The normal state for the data transfer phase
of the connection.
FIN-WAIT-1 - represents waiting for a connection termination request
from the remote TCP, or an acknowledgment of the connection
termination request previously sent.
FIN-WAIT-2 - represents waiting for a connection termination request
from the remote TCP.
CLOSE-WAIT - represents waiting for a connection termination request
from the local user.
CLOSING - represents waiting for a connection termination request
acknowledgment from the remote TCP.
LAST-ACK - represents waiting for an acknowledgment of the
connection termination request previously sent to the remote TCP
(which includes an acknowledgment of its connection termination
request).
TIME-WAIT - represents waiting for enough time to pass to be sure
the remote TCP received the acknowledgment of its connection
termination request.
CLOSED - represents no connection state at all.
A TCP connection progresses from one state to another in response to
events. The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,
ABORT, and STATUS; the incoming segments, particularly those
containing the SYN, ACK, RST and FIN flags; and timeouts.
The state diagram in figure 6 illustrates only state changes, together
with the causing events and resulting actions, but addresses neither
error conditions nor actions which are not connected with state
changes. In a later section, more detail is offered with respect to
the reaction of the TCP to events.
NOTE BENE: this diagram is only a summary and must not be taken as
the total specification.
+---------+ ---------\ active OPEN
| CLOSED | \ -----------
+---------+&amp;lt;---------\ \ create TCB
| ^ \ \ snd SYN
passive OPEN | | CLOSE \ \
------------ | | ---------- \ \
create TCB | | delete TCB \ \
V | \ \
+---------+ CLOSE | \
| LISTEN | ---------- | |
+---------+ delete TCB | |
rcv SYN | | SEND | |
----------- | | ------- | V
+---------+ snd SYN,ACK / \ snd SYN +---------+
| |&amp;lt;----------------- ------------------&amp;gt;| |
| SYN | rcv SYN | SYN |
| RCVD |&amp;lt;-----------------------------------------------| SENT |
| | snd ACK | |
| |------------------ -------------------| |
+---------+ rcv ACK of SYN \ / rcv SYN,ACK +---------+
| -------------- | | -----------
| x | | snd ACK
| V V
| CLOSE +---------+
| ------- | ESTAB |
| snd FIN +---------+
| CLOSE | | rcv FIN
V ------- | | -------
+---------+ snd FIN / \ snd ACK +---------+
| FIN |&amp;lt;----------------- ------------------&amp;gt;| CLOSE |
| WAIT-1 |------------------ | WAIT |
+---------+ rcv FIN \ +---------+
| rcv ACK of FIN ------- | CLOSE |
| -------------- snd ACK | ------- |
V x V snd FIN V
+---------+ +---------+ +---------+
|FINWAIT-2| | CLOSING | | LAST-ACK|
+---------+ +---------+ +---------+
| rcv ACK of FIN | rcv ACK of FIN |
| rcv FIN -------------- | Timeout=2MSL -------------- |
| ------- x V ------------ x V
\ snd ACK +---------+delete TCB +---------+
------------------------&amp;gt;|TIME WAIT|------------------&amp;gt;| CLOSED |
+---------+ +---------+
TCP Connection State Diagram
Figure 6.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Data can flow on an &lt;em>ESTABLISHED&lt;/em> state, that&amp;rsquo;s why I added an additional filter to the observability one-liners.&lt;/p>
&lt;p>So HTML &lt;code>img&lt;/code> element, with the TCP remote set as &lt;code>src&lt;/code> attribute, stays an &lt;em>ESTABLISHED&lt;/em> TCP socket, even after the HTML element has been removed from the DOM. But why doesn&amp;rsquo;t the browsers close the socket to the MJPEG server?&lt;/p>
&lt;h3 id="video-streaming-via-motion-jpeg">Video streaming via Motion JPEG&lt;/h3>
&lt;p>As I already showed in the playground script above, streaming MJPEG is rather simple.
I could find that information spread out on multiple sources.&lt;/p>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Motion_JPEG#Video_streaming">Wikipedia&lt;/a> has a nice overview:&lt;/p>
&lt;blockquote>
&lt;p>In response to a GET request for a MJPEG file or stream, the server streams the sequence of JPEG frames over HTTP. A special mime-type content type multipart/x-mixed-replace;boundary=&amp;lt;boundary-name&amp;gt; informs the client to expect several parts (frames) as an answer delimited by &amp;lt;boundary-name&amp;gt;. This boundary name is expressly disclosed within the MIME-type declaration itself. The TCP connection is not closed as long as the client wants to receive new frames and the server wants to provide new frames. [&amp;hellip;]&lt;/p>
&lt;p>Native web browser support includes: Safari, Google Chrome, Microsoft Edge[5] and Firefox.[6]&lt;/p>
&lt;/blockquote>
&lt;p>The specific MIME type in the content type of the HTTP response (that enables the server to push a stream to the client) originates from &lt;a href="https://web.archive.org/web/19981203153836/http://fishcam.netscape.com/assist/net_sites/pushpull.html">this post on Server Pushes&lt;/a> from &lt;em>Netscape&lt;/em> back in the day:&lt;/p>
&lt;blockquote>
&lt;p>For server push we use a variant of &amp;ldquo;multipart/mixed&amp;rdquo; called &amp;ldquo;multipart/x-mixed-replace&amp;rdquo;. The &amp;ldquo;x-&amp;rdquo; indicates this type is experimental. The &amp;ldquo;replace&amp;rdquo; indicates that each new data block will cause the previous data block to be replaced &amp;ndash; that is, new data will be displayed instead of (not in addition to) old data.&lt;/p>
&lt;p>So here&amp;rsquo;s an example of &amp;ldquo;multipart/x-mixed-replace&amp;rdquo; in action:&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">Content-type: multipart/x-mixed-replace;boundary=ThisRandomString
--ThisRandomString
Content-type: text/plain
Data for the first object.
--ThisRandomString
Content-type: text/plain
Data for the second and last object.
--ThisRandomString--
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>The key to the use of this technique is that the server does not push the whole &amp;ldquo;multipart/x-mixed-replace&amp;rdquo; message down all at once but rather sends down each successive data block whenever it sees fit. The HTTP connection stays open all the time, and the server pushes down new data blocks as rapidly or as infrequently as it wants, and in between data blocks the browser simply sits and waits for more data in the current window. The user can even go off and do other things in other windows; when the server has more data to send, it just pushes another data block down the pipe, and the appropriate window updates itself.&lt;/p>
&lt;p>So here&amp;rsquo;s exactly what happens:&lt;/p>
&lt;ul>
&lt;li>Following in the tradition of the standard &amp;ldquo;multipart/mixed&amp;rdquo;, &amp;ldquo;multipart/x-mixed-replace&amp;rdquo; messages are composed using a unique boundary line that separates each data object. Each data object has its own headers, allowing for an object-specific content type and other information to be specified.&lt;/li>
&lt;li>The specific behavior of &amp;ldquo;multipart/x-mixed-replace&amp;rdquo; is that each new data object replaces the previous data object. The browser gets rid of the first data object and instead displays the second data object.&lt;/li>
&lt;li>A &amp;ldquo;multipart/x-mixed-replace&amp;rdquo; message doesn&amp;rsquo;t have to end! That is, the server can just keep the connection open forever and send down as many new data objects as it wants. The process will then terminate if the user is no longer displaying that data stream in a browser window or if the browser severs the connection (e.g. the user presses the &amp;ldquo;Stop&amp;rdquo; button). We expect this will be the typical way people will use server push.&lt;/li>
&lt;li>The previous document will be cleared and the browser will begin displaying the next document when the &amp;ldquo;Content-type&amp;rdquo; header is found, or at the end of the headers otherwise, for a new data block.&lt;/li>
&lt;li>The current data block (document) is considered finished when the next message boundary is found.&lt;/li>
&lt;li>Together, the above two items mean that the server should push down the pipe: a set of headers (most likely including &amp;ldquo;Content-type&amp;rdquo;), the data itself, and a separator (message boundary). When the browser sees the separator, it knows to sit still and wait indefinitely for the next data block to arrive.&lt;/li>
&lt;/ul>
&lt;p>Putting it all together, here&amp;rsquo;s a Unix shell script that will cause the browser to display a new listing of processes running on a server every 5 seconds:&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#!/bin/sh
&lt;/span>&lt;span style="color:#75715e">&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;HTTP/1.0 200&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;Content-type: multipart/x-mixed-replace;boundary=---ThisRandomString---&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;---ThisRandomString---&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> true
&lt;span style="color:#66d9ef">do&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;Content-type: text/html&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;lt;h2&amp;gt;Processes on this machine updated every 5 seconds&amp;lt;/h2&amp;gt;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;time: &amp;#34;&lt;/span>
date
echo &lt;span style="color:#e6db74">&amp;#34;&amp;lt;p&amp;gt;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;lt;plaintext&amp;gt;&amp;#34;&lt;/span>
ps -el
echo &lt;span style="color:#e6db74">&amp;#34;---ThisRandomString---&amp;#34;&lt;/span>
sleep &lt;span style="color:#ae81ff">5&lt;/span>
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Following is an excerpt from the HTML specs by the WHATWG on &lt;a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#read-multipart-x-mixed-replace">multipart/x-mixed-replace&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.&lt;/p>
&lt;p>Thus, load events (and for that matter unload events) do fire for each body part loaded.&lt;/p>
&lt;/blockquote>
&lt;p>Can you notice the bit about the load events: &amp;ldquo;&lt;em>load events [&amp;hellip;] do fire for each body part loaded.&lt;/em>&amp;rdquo;? It seems that each received MJPEG frame should emit the &lt;code>load&lt;/code> event&amp;hellip; &lt;em>Brave&lt;/em> only emits the one for the first frame, but &lt;em>Firefox&lt;/em> seemingly does!&lt;/p>
&lt;p>Here are the relevant bits of the &amp;ldquo;&lt;a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#process-a-navigate-response">process a navigate response&lt;/a>&amp;quot;-section from the HTML spec:&lt;/p>
&lt;blockquote>
&lt;p>To process a navigate response, given a string navigationType, a boolean allowedToDownload, a boolean hasTransientActivation, and a navigation params navigationParams:&lt;/p>
&lt;pre>&lt;code>Let response be navigationParams's response.
Let browsingContext be navigationParams's browsing context.
Let failure be false.
If response is a network error, then set failure to true.
Otherwise, if the result of Should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, response, navigationParams's policy container's CSP list, navigationType, and browsingContext is &amp;quot;Blocked&amp;quot;, then set failure to true. [CSP]
Otherwise, if navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given response, browsingContext, and navigationParams's policy container's embedder policy is false, then set failure to true.
Otherwise, if the result of checking a navigation response's adherence to `X-Frame-Options` given response, browsingContext, and navigationParams's origin is false, then set failure to true.
If failure is true, then:
[...]
Return.
This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to users. [FETCH]
If response's status is 204 or 205, then return.
If response has a `Content-Disposition` header specifying the attachment disposition type, then:
[...]
Return.
Let type be the computed type of response.
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:
[...]
&amp;quot;multipart/x-mixed-replace&amp;quot;
Follow the steps given in the multipart/x-mixed-replace section providing navigationParams. Once the steps have completed, return.
[...]
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>Oki, so much for MJPEG streaming. The server is in charge of the framerate and both (server and client) can termination the connection. Let&amp;rsquo;s have a look at the spec for the HTML &lt;code>img&lt;/code> element.&lt;/p>
&lt;h3 id="htmlimageelement">HTMLImageElement&lt;/h3>
&lt;p>Obvious sources are the &lt;a href="https://html.spec.whatwg.org/#the-img-element">HTML spec by the WHATWG&lt;/a> and the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">elaborating notes on MDN&lt;/a>.&lt;/p>
&lt;p>I guessed what could be of interest for my bug is the &lt;a href="https://html.spec.whatwg.org/multipage/embedded-content.html#dom-img-complete-dev">&lt;code>complete&lt;/code> attribute&lt;/a>. &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement#htmlimageelement.complete">This bit on MDN&lt;/a> in particular catched by attention:&lt;/p>
&lt;blockquote>
&lt;p>Returns a boolean value that is true if the browser has finished fetching the image, whether successful or not. That means this value is also true if the image has no src value indicating an image to load.&lt;/p>
&lt;/blockquote>
&lt;p>The part about &lt;em>&amp;quot;[&amp;hellip;] is also true if the image has no src value [&amp;hellip;]&amp;quot;&lt;/em> lead me to the assumption that if I remove the &lt;code>src&lt;/code> attribute from the HTML element, then the browser might consider the load of the image as being &lt;strong>complete&lt;/strong>d and will properly close the established TCP socket.&lt;/p>
&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/complete#value">Here&lt;/a> is an even a more detailed flow:&lt;/p>
&lt;blockquote>
&lt;p>The image is considered completely loaded if any of the following are true:&lt;/p>
&lt;ul>
&lt;li>Neither the src nor the srcset attribute is specified.&lt;/li>
&lt;li>The srcset attribute is absent and the src attribute, while specified, is the empty string (&amp;quot;&amp;quot;).&lt;/li>
&lt;li>The image resource has been fully fetched and has been queued for rendering/compositing.&lt;/li>
&lt;li>The image element has previously determined that the image is fully available and ready for use.&lt;/li>
&lt;li>The image is &amp;ldquo;broken;&amp;rdquo; that is, the image failed to load due to an error or because image loading is disabled.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>So let me just try to remove the &lt;code>src&lt;/code> attribute in the unmount cycle of the component!&lt;/p>
&lt;h2 id="i-hope-well-learn-something-new-here">I hope we&amp;rsquo;ll learn something new here&amp;hellip;&lt;/h2>
&lt;p>So right before the call to &lt;code>img.remove()&lt;/code> in the vanilla SPA, I include a call to remove the &lt;code>src&lt;/code> attribute.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// ...same as above
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">removeImage&lt;/span>() {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stream&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">img&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#75715e">// without the removal of the `src` attribute, the stream will continue
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// loading data in the background
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">removeAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src&amp;#34;&lt;/span>);
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, when I observe the established sockets with the little hacky watcher again:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ watch -n 0.1 &lt;span style="color:#e6db74">&amp;#34;ss -HOna4t state established &amp;#39;( dst = 127.0.0.1:8001 )&amp;#39;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;I can see that the established TCP socket gets properly closed.&lt;/p>
&lt;p>Wow! What was missing is a surprising client-side &lt;code>img.removeAttribute(&amp;quot;src&amp;quot;)&lt;/code> right before the call to &lt;code>img.remove()&lt;/code>, otherwise the socket will stay open and continue to receive pushes from the MJPEG server.&lt;/p>
&lt;p>So in the &lt;em>react&lt;/em> SPA of my client I archieve the same behavior by using an effect hook. That should remove the attribute in the unmount cycle:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;react&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">StreamProps&lt;/span> {
&lt;span style="color:#75715e">// ...same as above
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">Stream&lt;/span>(&lt;span style="color:#a6e22e">props&lt;/span>: &lt;span style="color:#66d9ef">StreamProps&lt;/span>) {
&lt;span style="color:#75715e">// ...same as above
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`//0.0.0.0:8001/?resolution=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">resolution&lt;/span>.&lt;span style="color:#a6e22e">width&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">x&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">resolution&lt;/span>.&lt;span style="color:#a6e22e">height&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * use a ref to manage the &amp;#39;src&amp;#39; attribute in a manual fashion
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * NOTE: if we don&amp;#39;t manage the src attribute manually then the TCP socket will
&lt;/span>&lt;span style="color:#75715e"> * keep an established connection to the MJPEG server and receive the stream
&lt;/span>&lt;span style="color:#75715e"> * until it gets exhausted
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">imgRef&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">useRef&lt;/span>&amp;lt;&lt;span style="color:#f92672">React.HTMLImageElement&lt;/span>&amp;gt;(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">useEffect&lt;/span>(() &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">img&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">imgRef&lt;/span>.&lt;span style="color:#a6e22e">current&lt;/span>; &lt;span style="color:#75715e">// keep the ref to use it in the unmounting cycle
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">img&lt;/span>) {
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">src&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">img&lt;/span>) {
&lt;span style="color:#a6e22e">img&lt;/span>.&lt;span style="color:#a6e22e">removeAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src&amp;#34;&lt;/span>);
}
};
}, [&lt;span style="color:#a6e22e">src&lt;/span>]);
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * ...and replace the `src` attribute with a `ref`
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &amp;lt;&lt;span style="color:#f92672">img&lt;/span> &lt;span style="color:#a6e22e">alt&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;loading stream...&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">imgRef&lt;/span>} {&lt;span style="color:#a6e22e">...props&lt;/span>} /&amp;gt;;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;and just like that I only stream the data for the video that is also present in the DOM and the MJPEG server can properly garbage collect its unused streams!&lt;/p>
&lt;p>Going even further, now that the MJPEG server can garbage collect all the unused streams, I included some additional conditions to handle even smaller resolutions than &lt;code>720p&lt;/code> and safe some more resources.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>In this post I reproduced the bug properly, elaborated the process on how to isolate the problem and got to write some useful scripts that provide observability on established TCP sockets. I think it&amp;rsquo;s nice to see that modern frontend engineering involves quite some knowledge about a working system, the complexity of browsers and sometimes a thorough read through specs and historical references. What&amp;rsquo;s missing might be a look into the Chromium source code.&lt;/p>
&lt;p>There seems to be an interesting quirk with an &lt;code>Image&lt;/code> being loaded via &lt;code>multipart&lt;/code>-HTTP-pushes in an responsive implementation. In the end I just assume that an &lt;code>Image&lt;/code> doesn&amp;rsquo;t get garbage collected by the browser engine, as it is expected to &lt;code>complete&lt;/code> the loading process first. Maybe this clashes with &lt;code>multipart&lt;/code>-HTTP-pushes, especially after the &lt;code>load&lt;/code> event got emitted - and that emit happens, in contrast to spec, only once (on &lt;em>Brave&lt;/em>!). Regarding responsive images, I did also try out the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset">&lt;code>srcset&lt;/code> attribute&lt;/a> for a responsive behavior without any scripting, but that one had even more quirks, as the image with the higher quality is alwas preferred once loaded. I might cover this in a followup post. I wonder if there are other HTML elements that suffer from such surprises like the &lt;code>HTMLImageElement&lt;/code>?&lt;/p>
&lt;p>&amp;hellip;and, what was so cool about the bug?&lt;/p>
&lt;p>A cool bug is so complex that it becomes hard to avoid during development, even after making every decision reasonable well. Such a bug is deeply hidden in some spec, maybe even just an implicit behavior and can&amp;rsquo;t be easily looked up in any documentation of a library. I could have easily created such a bug myself and solving such a bug makes me feel like I could grow as a software engineer simply by fixing it. Unfortunately, cool bugs are rare!&lt;/p>
&lt;p>Here&amp;rsquo;s a quick list of all the awesome tools that were touched in this journey:&lt;/p>
&lt;ul>
&lt;li>&lt;code>netcat&lt;/code> (&lt;code>nc&lt;/code>)&lt;/li>
&lt;li>&lt;code>gstreamer&lt;/code> (&lt;code>gst-launch&lt;/code>)&lt;/li>
&lt;li>&lt;code>ss&lt;/code> (or &lt;code>netstat&lt;/code> / &lt;code>awk&lt;/code> for MacOS)&lt;/li>
&lt;/ul>
&lt;p>Thank you for having a look and stepping through it with me!&lt;/p></content></item></channel></rss>