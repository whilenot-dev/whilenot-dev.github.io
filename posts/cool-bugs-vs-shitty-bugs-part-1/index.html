<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Cool Bugs VS Shitty Bugs, Part 1: Cool Bugs - wh!le / blog</title><link rel=icon type=image/png href=/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Steaming video via Motion JPEG and counting established TCP sockets - a declarative promise with a catch"><meta property="og:image" content><meta property="og:title" content="Cool Bugs VS Shitty Bugs, Part 1: Cool Bugs"><meta property="og:description" content="Steaming video via Motion JPEG and counting established TCP sockets - a declarative promise with a catch"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.whilenot.dev/posts/cool-bugs-vs-shitty-bugs-part-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-10T14:29:10+02:00"><meta property="article:modified_time" content="2022-04-10T14:29:10+02:00"><meta property="og:site_name" content="wh!le / blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cool Bugs VS Shitty Bugs, Part 1: Cool Bugs"><meta name=twitter:description content="Steaming video via Motion JPEG and counting established TCP sockets - a declarative promise with a catch"><script src=https://blog.whilenot.dev/js/feather.min.js></script><link href=https://blog.whilenot.dev/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://blog.whilenot.dev/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css></head><body><div class=content><header><div class=main><a href=https://blog.whilenot.dev/>wh!le / blog</a></div><nav><a href=/tags>Tags</a>
<a href=/posts>Posts</a></nav></header><main><article><div class=title><h1 class=title>Cool Bugs VS Shitty Bugs, Part 1: Cool Bugs</h1><div class=meta>Posted on Apr 10, 2022</div></div><section class=body><h1 id=steaming-video-via-motion-jpeg-and-counting-established-tcp-sockets---a-declarative-promise-with-a-catch>Steaming video via Motion JPEG and counting established TCP sockets - a declarative promise with a catch</h1><p>Recently I had to debug a problem in an Single Page Application (SPA) regarding Motion JPEG streams for one of my clients. I found this journey so interesting that I wanted to share it as my first blog post.</p><p>The post should give the reader an introduction on what it means to do frontend engineering nowadays. What follows is a post that touches on <em>MJPEG streams</em>, <em>HTTP pushes</em>, <em>TCP sockets</em> and <em>their observability</em>. What I assumed to be a bug in either the sent application or even the <em>React</em> library, just turned out to surprise me and I think it could surprise others as well.</p><p>So let&rsquo;s step through it together and let me start by outlining the system of my client.</p><h2 id=describing-the-system>Describing the system</h2><p>The system of my client contains, among other services, a statically served SPA (written with <a href=https://reactjs.org/><em>React</em></a>) and a video stream server (written with <a href=https://www.ros.org/><em>ROS</em></a> in <em>C++</em>/<em>Python</em>).</p><p>The stream server offers its data to the SPA in the <a href=https://en.wikipedia.org/wiki/Motion_JPEG>Motion JPEG (<em>MJPEG</em>)</a> format. MJPEG is an rather archaic approach, but still does its job well enough and hides all video interaction from the UI.</p><p>In the shipped product both servers run on different hosts, but for this post let&rsquo;s assume the SPA is statically served via <code>:8000</code> and the MJPEG server is serving its video stream via <code>:8001</code>, both on the same host <code>0.0.0.0</code>.</p><p><img src=/images/cool-bugs-vs-shitty-bugs-part-1/system_overview.png alt=system_overview.png title="System overview"></p><p>The users are able to access the SPA via a Chromium-based browser and can then see the video stream in the center of the page. A responsive behavior is implemented as well, but apparently the system didn&rsquo;t work as expected&mldr;</p><h2 id=a-bug-in-todo>A bug in TODO</h2><p>At the beginning of the week I found a new bug-ticket and its description contained something like the following:</p><blockquote><p>By changing the size of the visible video stream in the UI more than 5 times, eg. by resizing the browser window, the video stream gets lost and the image just shows a blank background.</p></blockquote><p>With the description being elaborate enough, I started up the two affected servers:</p><ul><li>the one serving the <em>React</em> SPA</li><li>and the one MJPEG stream server</li></ul><p>&mldr;and assumed that the video server got exhausted. I could imediately confirm my assumption as its logs contained entries like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>[mjpeg_server] WARN: too many open streams (6/5)
</code></pre></div><p>By resizing the browser window with the <em>DevTools</em> on the sidebar and by having the network tab open (with the filter set to <code>Img</code>, assuming <em>Brave</em>), I can observe that there are still data pushed from the MJPEG server; even though the stream got presumably &ldquo;lost&rdquo;. Even more interesting, <strong>all URIs that were ever used to request a MJPEG stream since session start were still receiving server pushes</strong> with streaming data from the server.</p><p>So it looks like each resize event that alters the URI for a new stream request doesn&rsquo;t properly cleanup the streams that were previously requested. With each new such event the browser would just request another distinct stream from the MJPEG server and stack them up while keeping the older ones open.</p><p>Let&rsquo;s have a look at the source code to get some insights and to compare the observed behavior with the current implementation.</p><h2 id=some-of-the-systems-current-implementation>Some of the systems current implementation</h2><p>I just want to outline the concept here before I go on to create an isolated playground for the reader to try it out themselves.</p><h3 id=react-spa>React SPA</h3><p>The <em>React</em> component for the stream viewer looked something like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// stream.tsx
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>React</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>StreamProps</span> {
  <span style=color:#75715e>/**
</span><span style=color:#75715e>   * visible height of the wrapping element in px
</span><span style=color:#75715e>   */</span>
  <span style=color:#a6e22e>height</span>: <span style=color:#66d9ef>number</span>;
  <span style=color:#75715e>/**
</span><span style=color:#75715e>   * visible width of the wrapping element in px
</span><span style=color:#75715e>   */</span>
  <span style=color:#a6e22e>width</span>: <span style=color:#66d9ef>number</span>;
}

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Stream</span>(<span style=color:#a6e22e>props</span>: <span style=color:#66d9ef>StreamProps</span>) {
  <span style=color:#75715e>/**
</span><span style=color:#75715e>   * choose between two possible streams based on the max visible size
</span><span style=color:#75715e>   */</span>
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resolution</span> <span style=color:#f92672>=</span>
    <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1080</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1920</span>
      <span style=color:#f92672>?</span> {
          <span style=color:#a6e22e>height</span>: <span style=color:#66d9ef>1080</span>,
          <span style=color:#a6e22e>width</span>: <span style=color:#66d9ef>1920</span>,
        }
      <span style=color:#f92672>:</span> {
          <span style=color:#a6e22e>height</span>: <span style=color:#66d9ef>720</span>,
          <span style=color:#a6e22e>width</span>: <span style=color:#66d9ef>1280</span>,
        };

  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`//0.0.0.0:8001/?resolution=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>width</span><span style=color:#e6db74>}</span><span style=color:#e6db74>x</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>height</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;

  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>alt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;loading stream...&#34;</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>src</span>} {<span style=color:#a6e22e>...props</span>} /&gt;;
}
</code></pre></div><p>A simple stateless functional component in <em>TypeScript</em> that, depending on the available size, chooses a stream resolution to be either <code>1080p</code> or <code>720p</code>; adaptive streaming in a manual fashion, presumably to save some bandwidth and lower the computing resources on the MJPEG server. Its parent component did guarantee the aspect ratio and a proper handling of the <code>resize</code> event.</p><p>But, as I observed in the reproduction step above, even though the <code>resize</code> event causes a correct re-render of the <code>Stream</code>-component, the unmounted components were still receiving HTTP pushes from previously used streams. The stream just didn&rsquo;t get released in the unmount cycle of the component, as I honestly would expect from this implementation and the declarative promise of <em>React</em>&mldr; so, a bug in <em>React</em>?</p><h3 id=mjpeg-server>MJPEG Server</h3><p>The MJPEG video stream server is implemented in <em>C++</em> and for proprietary reasons I just want to outline the implemented behavior here with a short description. Later on I&rsquo;ll provide some code, so we can create a MJPEG server the FOSS way.</p><p>Internally the streaming server gets its images by subscribing to a <a href=http://wiki.ros.org/Topics><em>ROS</em> Topic</a>. It receives frames in a certain frequency, waits for a browser client to request a stream and then goes on with the encoding of a new MJPEG stream for each unique URI.</p><p>The browser client is in charge of some stream options via the query: <em>resolution</em>, <em>framerate</em>, <em>quality</em> etc. <code>/?resolution=1920x1080</code> and <code>/?resolution=1280x720</code> will produce two distinct MJPEG video streams with different resolutions, just as we&rsquo;ve seen in the <em>React</em> <code>Stream</code>-component above. As present in the server logs, the maximum number of MJPEG streams is limited to 5 streams for a single server. Each client that requests a stream with an identical URI will consume the same MJPEG stream.</p><p>There are some comments in the source code mentioning:</p><blockquote><p>Every created stream will be garbage collected after there is no application consuming it anymore and some timeout emitted after its last consumption.</p></blockquote><p>To isolate the problem (and to provide some usable example code for the readers of this post) let me create an environment as vanilla as possible&mldr;</p><h2 id=an-isolated-environment-as-playground>An isolated environment as playground</h2><p>For reproducibility purposes I want to provide some simplified versions of the two mentioned servers. I need to create one server that provides an endless MJPEG video stream via HTTP and one that serves an simple SPA, so a request to the MJPEG stream can be done via the <code>src</code> attribute on an HTML <code>img</code> element.</p><p><strong>tl;dr</strong> you can clone the mentioned files <a href=https://github.com/whilenot-dev/cool-bugs-vs-shitty-bugs-part-1>here</a>.</p><h3 id=a-simple-mjpeg-server>A simple MJPEG server</h3><p>The following packages are needed to launch the MJPEG server successfully (assuming <em>Fedora</em>):</p><ul><li><a href=https://en.wikipedia.org/wiki/Netcat><em>netcat</em></a></li><li><a href=https://gstreamer.freedesktop.org><em>gstreamer1</em></a></li><li><a href=https://gstreamer.freedesktop.org><em>gstreamer1-plugins-good</em></a></li></ul><p>The way MJPEG is streamed via HTTP is with the <a href=https://en.wikipedia.org/wiki/MIME#x-mixed-replace><code>multipart/x-mixed-replace</code> MIME type</a>. I will cover the <em>why</em>&rsquo;s and <em>how</em>&rsquo;s later on when I go a bit into detail of the involved specs. But for now, let me just echo an HTTP MJPEG stream to <em>STDOUT</em> first.</p><p>I use <code>gstreamer</code>&rsquo;s <code>gst-launch</code> cli to create a simple MJPEG media pipeline and, like in the <em>Netscape</em> example in the section below about specs, I prepend this load with some <code>echo</code>ing for the initial <code>multipart</code> HTTP-header:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># start-stream.sh</span>

<span style=color:#75715e>#!/bin/bash</span>

BOUNDARY_GST_PREFIX<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;--&#34;</span> <span style=color:#75715e># the gstreamer plugin seems to have a prefix for the boundary</span>
BOUNDARY<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-ThisRandomString---&#34;</span>

<span style=color:#75715e># multipart header</span>
echo <span style=color:#e6db74>&#34;HTTP/1.0 200&#34;</span>
echo <span style=color:#e6db74>&#34;Content-type: multipart/x-mixed-replace;boundary=</span><span style=color:#e6db74>${</span>BOUNDARY_GST_PREFIX<span style=color:#e6db74>}${</span>BOUNDARY<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
echo <span style=color:#e6db74>&#34;&#34;</span>

<span style=color:#75715e># multipart body parts</span>
gst-launch-1.0 -q <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    videotestsrc is-live<span style=color:#f92672>=</span>true pattern<span style=color:#f92672>=</span>ball motion<span style=color:#f92672>=</span>sweep ! <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    videorate rate<span style=color:#f92672>=</span>0.04 ! <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    video/x-raw,width<span style=color:#f92672>=</span>640,height<span style=color:#f92672>=</span>480,framerate<span style=color:#f92672>=</span>60/1 ! <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    jpegenc quality<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> ! <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    multipartmux boundary<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>BOUNDARY<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> ! <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    filesink append<span style=color:#f92672>=</span>true location<span style=color:#f92672>=</span>/dev/stdout <span style=color:#75715e># the fdsink plugin didn&#39;t provide the needed `append` property to include the echoed header</span>
</code></pre></div><p>I&rsquo;m picking the sweeping ball test video source of gstreamer as my infinite stream here. Executing this script in the terminal will seemingly just output some gibberish (JPEG binary data), but inbetween you should be able to see that the necessary HTTP headers are in there as well.</p><p>A proper terminal output is ready now, so let me make use of <code>netcat</code> (<code>nc</code>) in listen mode to provide this output as an actual HTTP response from an server:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># serve.sh</span>

<span style=color:#75715e>#!/bin/bash</span>

DIR<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span> dirname <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span> realpath <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>)</span>

nc -l -k -p <span style=color:#ae81ff>8001</span> -c <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/start-stream.sh&#34;</span>
</code></pre></div><p>So with a directory structure like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>.
├── serve.sh
└── start-stream.sh

<span style=color:#ae81ff>0</span> directories, <span style=color:#ae81ff>2</span> files
</code></pre></div><p>&mldr;I can start my hacky MJPEG server with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ./serve.sh
</code></pre></div><p>&mldr;to listen for HTTP requests on <code>0.0.0.0:8001</code> and respond with a MJPEG video stream.</p><p><img src=/images/cool-bugs-vs-shitty-bugs-part-1/playground_mjpeg.png alt=playground_mjpeg.png title="Playground of MJPEG Stream"></p><p>Now to the SPA&mldr;</p><h3 id=a-simple-vanilla-spa>A simple vanilla SPA</h3><p>For the SPA I also want to stay vanilla and try to work without any 3rd party library (eg. <em>React</em>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!-- index.html --&gt;</span>

&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
  &lt;<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;UTF-8&#34;</span> /&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>http-equiv</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;X-UA-Compatible&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;IE=edge&#34;</span> /&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;viewport&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;width=device-width, initial-scale=1.0&#34;</span> /&gt;
    &lt;<span style=color:#f92672>title</span>&gt;MJPEG Stream&lt;/<span style=color:#f92672>title</span>&gt;
    &lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/main.js&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
  &lt;/<span style=color:#f92672>head</span>&gt;
  &lt;<span style=color:#f92672>body</span>&gt;&lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// main.js
</span><span style=color:#75715e></span>
document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;DOMContentLoaded&#34;</span>, () =&gt; {
  <span style=color:#a6e22e>main</span>();
});

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#75715e>// just a single mount-/unmount-cycle
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>addStream</span>();
  window.<span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>removeStream</span>, <span style=color:#ae81ff>10000</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>addStream</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#34;img&#34;</span>);

  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;stream&#34;</span>);
  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;alt&#34;</span>, <span style=color:#e6db74>&#34;loading stream...&#34;</span>);
  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;src&#34;</span>, <span style=color:#e6db74>&#34;//0.0.0.0:8001/&#34;</span>); <span style=color:#75715e>// ref to the netcat MJPEG server above
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;height&#34;</span>, <span style=color:#e6db74>&#34;480&#34;</span>);
  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;width&#34;</span>, <span style=color:#e6db74>&#34;640&#34;</span>);

  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;load&#34;</span>, () =&gt; {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`images loaded: </span><span style=color:#e6db74>${</span><span style=color:#f92672>++</span><span style=color:#a6e22e>count</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  });

  document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>img</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>removeStream</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;stream&#34;</span>);
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>img</span>) {
    <span style=color:#66d9ef>return</span>;
  }

  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>remove</span>();
}
</code></pre></div><p>Instead of removing the HTML element from the DOM through <em>React</em> with an <code>resize</code> event, I just use a timeout of 10s. This will provide - to my surprise - a setup that is already sufficient enough to recreate the observed bug, as I will now show.</p><p>I can serve those files with the static file server of my choice:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># serve.sh</span>

<span style=color:#75715e>#!/bin/bash</span>

DIR<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span> dirname <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span> realpath <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>)</span>

python -m http.server --directory <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>8000</span>
</code></pre></div><p>&mldr;so with a directory structure like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>.
├── index.html
├── main.js
└── serve.sh

<span style=color:#ae81ff>0</span> directories, <span style=color:#ae81ff>3</span> files
</code></pre></div><p>&mldr;I can start the SPA server with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ./serve.sh
</code></pre></div><p>&mldr;and can consum the MJPEG stream with my vanilla SPA on <code>0.0.0.0:8000</code>.</p><p><img src=/images/cool-bugs-vs-shitty-bugs-part-1/playground_spa.png alt=playground_spa.png title="Playground of SPA"></p><p>Let&rsquo;s do some observations!</p><h2 id=observability>Observability</h2><p>With the playground in place, let me observe the behavior of the loading MJPEG stream more closely.</p><h3 id=playing-on-the-playground>Playing on the playground</h3><p>The browser already gives me quite some information on the network activity, even before consulting additional tools. With a visit on <code>0.0.0.0:8000</code> it lets me observe the following things.</p><p>On <em>Brave</em>:</p><ul><li>the images of the stream get properly rendered without stutter for 10s</li><li>the logs contain a single entry: <code>images loaded: 1</code></li><li>the stream keeps loading in the background after the HTML <code>img</code> element has been removed from the DOM</li></ul><p><img src=/images/cool-bugs-vs-shitty-bugs-part-1/playground_bug.gif alt=playground_bug.gif title="Bug in playground"></p><p>On <em>Firefox</em> (just for completeness):</p><ul><li>no image of the stream is shown (just an occasional single frame on my system, if I&rsquo;m even lucky)</li><li>there are quite some log entries á la <code>images loaded: x</code>, seemingly for each multipart body part</li><li>the stream also keeps loading in the background after the HTML <code>img</code> element has been removed from the DOM (and it even keeps logging entries!)</li></ul><p>My client just focusses on Chromium based browsers with their product, but <em>UH OH!</em> this difference in modern browser engines is worrysome. Why does the browser keep receiving data after the <code>img</code> HTML element has been removed from the DOM in both cases?</p><p>Let me observe the established TCP sockets for the MJPEG server on OS level.</p><h3 id=making-established-tcp-sockets-visible>Making established TCP sockets visible</h3><p>After feeling enlightened and motivated by <em>Brendan Gregg</em>&rsquo;s books <em>BPF Performance Tools: Linux System and Application Observability</em> and <em>Systems Performance: Enterprise and the Cloud</em>, let me get a list of all the established TCP sockets, from the browser (source) to the MJPEG server (destination).</p><p>With both servers running on my machine (with the scripts above) I can observe the established sockets for my destination with <a href=https://www.man7.org/linux/man-pages/man8/ss.8.html>ss</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ss -HOna4t state established <span style=color:#e6db74>&#39;( dst = 127.0.0.1:8001 )&#39;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>0      0       127.0.0.1:59590 127.0.0.1:8001
</code></pre></div><p>To observe any changes more easily I can <a href=https://www.man7.org/linux/man-pages/man1/watch.1.html>watch</a> the output of the command also continuously as frequent as every 100ms.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ watch -n 0.1 <span style=color:#e6db74>&#34;ss -HOna4t state established &#39;( dst = 127.0.0.1:8001 )&#39;&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Every 0.1s: ss -HOna4t ...  dell-precision-5560.localdomain: Fri Apr 1 21:28:12 2022

0      0       127.0.0.1:59590 127.0.0.1:8001
</code></pre></div><p>If you don&rsquo;t have <code>ss</code> available on your system (maybe on MacOS?), <a href=https://man7.org/linux/man-pages/man8/netstat.8.html>netstat</a> and <a href=https://man7.org/linux/man-pages/man1/awk.1p.html>awk</a> provide similar capabilities.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ watch -n 0.1 <span style=color:#e6db74>&#34;netstat -4nt | awk &#39;&#34;</span><span style=color:#e6db74>&#39;{ if ($5 == &#34;127.0.0.1:8001&#34; &amp;&amp; $6 == &#34;ESTABLISHED&#34;) print $0 }&#39;</span><span style=color:#e6db74>&#34;&#39;&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Every 0.1s: netstat -4n...  dell-precision-5560.localdomain: Fri Apr 1 21:29:28 2022

tcp        0	  0 127.0.0.1:59592         127.0.0.1:8001          ESTABLISHED
</code></pre></div><p>If I&rsquo;m only interested in the <strong>number</strong> of established sockets, I could narrow it down even further to a single numeric value. With one line per socket I could just count the number of lines.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ watch -n 0.1 <span style=color:#e6db74>&#34;ss -HOna4t state established &#39;( dst = 127.0.0.1:8001 )&#39; | wc -l&#34;</span>
</code></pre></div><p>&mldr;or with <code>netstat</code> / <code>awk</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ watch -n 0.1 <span style=color:#e6db74>&#34;netstat -4nt | awk &#39;&#34;</span><span style=color:#e6db74>&#39;{ if ($5 == &#34;127.0.0.1:8001&#34; &amp;&amp; $6 == &#34;ESTABLISHED&#34;) print $0 }&#39;</span><span style=color:#e6db74>&#34;&#39; | wc -l&#34;</span>
</code></pre></div><p>With one of those observability one-lines running in the terminal I now have the visible indicator on OS level. I can clearly see that the established TCP socket doesn&rsquo;t get closed after the HTML <code>img</code> element has been removed from the DOM.</p><p>We knew that one before by deriving that info from the network tab in the <em>DevTools</em>, but making it scriptable in the terminal could give us some idea on how to test this behavior in an browser-independent, automated way.</p><p>Let me have a look at the specs. Maybe this behavior is expected or maybe they could give me another hint&mldr;</p><h2 id=gathering-some-insights-on-some-involved-specs>Gathering some insights on some involved specs</h2><p>Let&rsquo;s step from lowest to highest level: TCP sockets, MJPEG streaming via HTTP pushes, and the DOM elements.</p><h3 id=tcp--rfc-793httpswwwrfc-editororgrfcrfc793>TCP / <a href=https://www.rfc-editor.org/rfc/rfc793>RFC 793</a></h3><p>Did you ever had a look at the TCP RFC?</p><p>What interests me in this case is the section about the different <a href=https://www.rfc-editor.org/rfc/rfc793#section-3.2>states</a> that a TCP socket can have:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>  A connection progresses through a series of states during its
  lifetime.  The states are:  LISTEN, SYN-SENT, SYN-RECEIVED,
  ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
  TIME-WAIT, and the fictional state CLOSED.  CLOSED is fictional
  because it represents the state when there is no TCB, and therefore,
  no connection.  Briefly the meanings of the states are:

    LISTEN - represents waiting for a connection request from any remote
    TCP and port.

    SYN-SENT - represents waiting for a matching connection request
    after having sent a connection request.

    SYN-RECEIVED - represents waiting for a confirming connection
    request acknowledgment after having both received and sent a
    connection request.

    ESTABLISHED - represents an open connection, data received can be
    delivered to the user.  The normal state for the data transfer phase
    of the connection.

    FIN-WAIT-1 - represents waiting for a connection termination request
    from the remote TCP, or an acknowledgment of the connection
    termination request previously sent.

    FIN-WAIT-2 - represents waiting for a connection termination request
    from the remote TCP.

    CLOSE-WAIT - represents waiting for a connection termination request
    from the local user.

    CLOSING - represents waiting for a connection termination request
    acknowledgment from the remote TCP.

    LAST-ACK - represents waiting for an acknowledgment of the
    connection termination request previously sent to the remote TCP
    (which includes an acknowledgment of its connection termination
    request).

    TIME-WAIT - represents waiting for enough time to pass to be sure
    the remote TCP received the acknowledgment of its connection
    termination request.

    CLOSED - represents no connection state at all.

  A TCP connection progresses from one state to another in response to
  events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,
  ABORT, and STATUS; the incoming segments, particularly those
  containing the SYN, ACK, RST and FIN flags; and timeouts.

  The state diagram in figure 6 illustrates only state changes, together
  with the causing events and resulting actions, but addresses neither
  error conditions nor actions which are not connected with state
  changes.  In a later section, more detail is offered with respect to
  the reaction of the TCP to events.

  NOTE BENE:  this diagram is only a summary and must not be taken as
  the total specification.

                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+&lt;---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |&lt;-----------------           ------------------&gt;|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |&lt;-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |
   | --------------   snd ACK   |                           ------- |
   V        x                   V                           snd FIN V
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
   |  -------              x       V    ------------        x       V
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
                               Figure 6.
</code></pre></div><p>Data can flow on an <em>ESTABLISHED</em> state, that&rsquo;s why I added an additional filter to the observability one-liners.</p><p>So an HTML <code>img</code> element, with the TCP remote set in the <code>src</code> attribute, creates and keeps an <em>ESTABLISHED</em> TCP socket, even after the HTML element has been removed from the DOM. But why doesn&rsquo;t the browser close the socket to the MJPEG server?</p><h3 id=video-streaming-via-motion-jpeg>Video streaming via Motion JPEG</h3><p>Streaming MJPEG is rather simple, as I already showed in the playground script above. I could find that information spread out on multiple sources. (I think the following specs are interesting, but feel free to skim those if you&rsquo;re not into specs that much.)</p><p><a href=https://en.wikipedia.org/wiki/Motion_JPEG#Video_streaming>Wikipedia</a> has a nice overview:</p><blockquote><p>In response to a GET request for a MJPEG file or stream, the server streams the sequence of JPEG frames over HTTP. A special mime-type content type multipart/x-mixed-replace;boundary=&lt;boundary-name> informs the client to expect several parts (frames) as an answer delimited by &lt;boundary-name>. This boundary name is expressly disclosed within the MIME-type declaration itself. The TCP connection is not closed as long as the client wants to receive new frames and the server wants to provide new frames. [&mldr;]</p></blockquote><p>The specific MIME type in the content type of the HTTP response (that enables the server to push a stream to the client) originates from <a href=https://web.archive.org/web/19981203153836/http://fishcam.netscape.com/assist/net_sites/pushpull.html>this post on Server Pushes</a> from <em>Netscape</em> back in the day:</p><blockquote><p>For server push we use a variant of &ldquo;multipart/mixed&rdquo; called &ldquo;multipart/x-mixed-replace&rdquo;. The &ldquo;x-&rdquo; indicates this type is experimental. The &ldquo;replace&rdquo; indicates that each new data block will cause the previous data block to be replaced &ndash; that is, new data will be displayed instead of (not in addition to) old data.</p><p>So here&rsquo;s an example of &ldquo;multipart/x-mixed-replace&rdquo; in action:</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Content-type: multipart/x-mixed-replace;boundary=ThisRandomString

--ThisRandomString
Content-type: text/plain

Data for the first object.

--ThisRandomString
Content-type: text/plain

Data for the second and last object.

--ThisRandomString--
</code></pre></div><blockquote><p>[&mldr;]</p><p>So here&rsquo;s exactly what happens:</p><ul><li>Following in the tradition of the standard &ldquo;multipart/mixed&rdquo;, &ldquo;multipart/x-mixed-replace&rdquo; messages are composed using a unique boundary line that separates each data object. Each data object has its own headers, allowing for an object-specific content type and other information to be specified.</li><li>The specific behavior of &ldquo;multipart/x-mixed-replace&rdquo; is that each new data object replaces the previous data object. The browser gets rid of the first data object and instead displays the second data object.</li><li>A &ldquo;multipart/x-mixed-replace&rdquo; message doesn&rsquo;t have to end! That is, the server can just keep the connection open forever and send down as many new data objects as it wants. The process will then terminate if the user is no longer displaying that data stream in a browser window or if the browser severs the connection (e.g. the user presses the &ldquo;Stop&rdquo; button). We expect this will be the typical way people will use server push.</li><li>The previous document will be cleared and the browser will begin displaying the next document when the &ldquo;Content-type&rdquo; header is found, or at the end of the headers otherwise, for a new data block.</li><li>The current data block (document) is considered finished when the next message boundary is found.</li><li>Together, the above two items mean that the server should push down the pipe: a set of headers (most likely including &ldquo;Content-type&rdquo;), the data itself, and a separator (message boundary). When the browser sees the separator, it knows to sit still and wait indefinitely for the next data block to arrive.</li></ul><p>Putting it all together, here&rsquo;s a Unix shell script that will cause the browser to display a new listing of processes running on a server every 5 seconds:</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/sh
</span><span style=color:#75715e></span>echo <span style=color:#e6db74>&#34;HTTP/1.0 200&#34;</span>
echo <span style=color:#e6db74>&#34;Content-type: multipart/x-mixed-replace;boundary=---ThisRandomString---&#34;</span>
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;---ThisRandomString---&#34;</span>
<span style=color:#66d9ef>while</span> true
<span style=color:#66d9ef>do</span>
echo <span style=color:#e6db74>&#34;Content-type: text/html&#34;</span>
echo <span style=color:#e6db74>&#34;&#34;</span>
echo <span style=color:#e6db74>&#34;&lt;h2&gt;Processes on this machine updated every 5 seconds&lt;/h2&gt;&#34;</span>
echo <span style=color:#e6db74>&#34;time: &#34;</span>
date
echo <span style=color:#e6db74>&#34;&lt;p&gt;&#34;</span>
echo <span style=color:#e6db74>&#34;&lt;plaintext&gt;&#34;</span>
ps -el
echo <span style=color:#e6db74>&#34;---ThisRandomString---&#34;</span>
sleep <span style=color:#ae81ff>5</span>
<span style=color:#66d9ef>done</span>
</code></pre></div><p>So much to the historic <em>Netscape</em> post.</p><p>The following is an excerpt from the HTML specs by the WHATWG on <a href=https://html.spec.whatwg.org/multipage/browsing-the-web.html#read-multipart-x-mixed-replace>multipart/x-mixed-replace</a>:</p><blockquote><p>For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.</p><p>Thus, load events (and for that matter unload events) do fire for each body part loaded.</p></blockquote><p>Can you notice the bit about the load events: &ldquo;<em>load events [&mldr;] do fire for each body part loaded.</em>&rdquo;? It seems that each received MJPEG frame should emit the <code>load</code> event&mldr; <em>Brave</em> only emits the one for the first frame, but <em>Firefox</em> seemingly does emit on all frames!</p><p>Here are the relevant bits of the &ldquo;<a href=https://html.spec.whatwg.org/multipage/browsing-the-web.html#process-a-navigate-response>process a navigate response</a>"-section from the HTML spec:</p><blockquote><p>To process a navigate response, given a string navigationType, a boolean allowedToDownload, a boolean hasTransientActivation, and a navigation params navigationParams:</p><pre><code>Let response be navigationParams's response.

Let browsingContext be navigationParams's browsing context.

Let failure be false.

If response is a network error, then set failure to true.

Otherwise, if the result of Should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, response, navigationParams's policy container's CSP list, navigationType, and browsingContext is &quot;Blocked&quot;, then set failure to true. [CSP]

Otherwise, if navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given response, browsingContext, and navigationParams's policy container's embedder policy is false, then set failure to true.

Otherwise, if the result of checking a navigation response's adherence to `X-Frame-Options` given response, browsingContext, and navigationParams's origin is false, then set failure to true.

If failure is true, then:

    [...]

    Return.

This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to users. [FETCH]

If response's status is 204 or 205, then return.

If response has a `Content-Disposition` header specifying the attachment disposition type, then:

    [...]

    Return.

Let type be the computed type of response.

If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:

[...]

&quot;multipart/x-mixed-replace&quot;
    Follow the steps given in the multipart/x-mixed-replace section providing navigationParams. Once the steps have completed, return.

[...]
</code></pre></blockquote><p>Oki, so much for MJPEG streaming. The server is in charge of the framerate and both (server and client) can terminate the connection. Let&rsquo;s have a look at the spec for the HTML <code>img</code> element.</p><h3 id=htmlimageelement>HTMLImageElement</h3><p>Obvious sources are the <a href=https://html.spec.whatwg.org/#the-img-element>HTML spec by the WHATWG</a> and the <a href=https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement>elaborating notes on MDN</a>.</p><p>I guessed what could be of interest for my bug is the <a href=https://html.spec.whatwg.org/multipage/embedded-content.html#dom-img-complete-dev><code>complete</code> attribute</a>. <a href=https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement#htmlimageelement.complete>This bit on MDN</a> in particular caught by attention:</p><blockquote><p>Returns a boolean value that is true if the browser has finished fetching the image, whether successful or not. That means this value is also true if the image has no src value indicating an image to load.</p></blockquote><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/complete#value>Here</a> is even more detail about the use of the <code>complete</code>-attribute:</p><blockquote><p>The image is considered completely loaded if any of the following are true:</p><ul><li>Neither the src nor the srcset attribute is specified.</li><li>The srcset attribute is absent and the src attribute, while specified, is the empty string ("").</li><li>The image resource has been fully fetched and has been queued for rendering/compositing.</li><li>The image element has previously determined that the image is fully available and ready for use.</li><li>The image is &ldquo;broken;&rdquo; that is, the image failed to load due to an error or because image loading is disabled.</li></ul></blockquote><p>The part about <em>"[&mldr;] is also true if the image has no src value [&mldr;]"</em> and <em>&ldquo;The image is considered completely loaded if [&mldr;] Neither the src nor the srcset attribute is specified."</em> lead me to the assumption that if I remove the <code>src</code> attribute from the HTML element, then the browser might consider the load of the image as being <strong>complete</strong>d and will properly close the established TCP socket.</p><p>So let me just try to remove the <code>src</code> attribute before I remove the element from the DOM!</p><h2 id=i-hope-well-learn-something-new-here>I hope we&rsquo;ll learn something new here&mldr;</h2><p>So right before the call to <code>img.remove()</code> in the vanilla SPA, I include a call to remove the <code>src</code> attribute.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// ...same as above
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>removeImage</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;stream&#34;</span>);
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>img</span>) {
    <span style=color:#66d9ef>return</span>;
  }

  <span style=color:#75715e>// without the removal of the `src` attribute, the stream will continue
</span><span style=color:#75715e></span>  <span style=color:#75715e>// loading data in the background
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>removeAttribute</span>(<span style=color:#e6db74>&#34;src&#34;</span>);

  <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>remove</span>();
}
</code></pre></div><p>Now, when I observe the established sockets with the little hacky watcher again:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ watch -n 0.1 <span style=color:#e6db74>&#34;ss -HOna4t state established &#39;( dst = 127.0.0.1:8001 )&#39;&#34;</span>
</code></pre></div><p>&mldr;I can see that the established TCP socket gets closed properly.</p><p><img src=/images/cool-bugs-vs-shitty-bugs-part-1/playground_fix.gif alt=playground_fix.gif title="Fix in playground"></p><p>Wow! What was missing is a surprising client-side <code>img.removeAttribute("src")</code> right before the call to <code>img.remove()</code>, otherwise the socket will stay open and continue to receive pushes from the MJPEG server. (As a friend later pointed out I was <a href=https://stackoverflow.com/questions/5278304/how-to-cancel-an-image-from-loading>not alone</a> with my assumption.)</p><p>So in the <em>React</em> SPA of my client I archieve the same behavior by using an effect hook. That one should remove the attribute in the unmount cycle:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>React</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>StreamProps</span> {
  <span style=color:#75715e>// ...same as above
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Stream</span>(<span style=color:#a6e22e>props</span>: <span style=color:#66d9ef>StreamProps</span>) {
  <span style=color:#75715e>// ...same as above
</span><span style=color:#75715e></span>
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`//0.0.0.0:8001/?resolution=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>width</span><span style=color:#e6db74>}</span><span style=color:#e6db74>x</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>resolution</span>.<span style=color:#a6e22e>height</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;

  <span style=color:#75715e>/**
</span><span style=color:#75715e>   * use a ref to manage the &#39;src&#39; attribute in a manual fashion
</span><span style=color:#75715e>   *
</span><span style=color:#75715e>   * NOTE: if we don&#39;t manage the src attribute manually then the TCP socket will
</span><span style=color:#75715e>   * keep an established connection to the MJPEG server and receive the stream
</span><span style=color:#75715e>   * until it gets exhausted
</span><span style=color:#75715e>   */</span>
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>imgRef</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>useRef</span>&lt;<span style=color:#f92672>React.HTMLImageElement</span>&gt;(<span style=color:#66d9ef>null</span>);
  <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>useEffect</span>(() <span style=color:#f92672>=&gt;</span> {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>imgRef</span>.<span style=color:#a6e22e>current</span>; <span style=color:#75715e>// keep the ref to use it in the unmounting cycle
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span>) {
      <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;src&#34;</span>, <span style=color:#a6e22e>src</span>);
    }

    <span style=color:#66d9ef>return</span> () <span style=color:#f92672>=&gt;</span> {
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span>) {
        <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>removeAttribute</span>(<span style=color:#e6db74>&#34;src&#34;</span>);
      }
    };
  }, [<span style=color:#a6e22e>src</span>]);

  <span style=color:#75715e>/**
</span><span style=color:#75715e>   * ...and replace the `src` attribute with a `ref`
</span><span style=color:#75715e>   */</span>
  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>alt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;loading stream...&#34;</span> <span style=color:#a6e22e>ref</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>imgRef</span>} {<span style=color:#a6e22e>...props</span>} /&gt;;
}
</code></pre></div><p>&mldr;and just like that I only stream the data for the video that is also present in the DOM. Finally the MJPEG server can properly garbage collect its unused streams!</p><p>Going further, I included some additional conditions to handle even smaller resolutions than <code>720p</code> to save even more resources.</p><h2 id=conclusion>Conclusion</h2><p>In this post I reproduced the bug properly, elaborated the process on how to isolate the problem and got to write some useful scripts that provide observability of established TCP sockets. I think it&rsquo;s nice to see that modern frontend engineering involves quite some knowledge about a working system, the complexity of browsers and sometimes a thorough read through specs and historical references. What&rsquo;s missing might be a look into the Chromium source code.</p><p>There seems to be an interesting quirk with an <code>Image</code> being loaded via <code>multipart</code>-HTTP-pushes in an responsive implementation. In the end I just assume that an <code>Image</code> doesn&rsquo;t get garbage collected by the browser engine after the removal from the DOM, as it&rsquo;s expected to <code>complete</code> the loading of the resource first. Maybe this behavior clashes with <code>multipart</code>-HTTP-pushes, especially together with the behavior of the <code>load</code> event as that one doesn&rsquo;t even seem to be according to spec. The declarative promise of <em>React</em> just distorted my perspective regarding source fetching here, but I also think it shouldn&rsquo;t make an effort to provide a declarative solution.</p><p>Regarding responsive images, I did also try out the <a href=https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset><code>srcset</code> attribute</a> for multi-source fetching without any scripting, but that one had even more quirks, since the image with the higher quality was (once loaded) always the preferred one. I might cover this in a followup post and wonder if there are other HTML elements that suffer from such surprises like the <code>HTMLImageElement</code>?</p><p>&mldr;and, what was so cool about the bug?</p><p>A cool bug is so complex that it becomes hard to avoid during development, even after making every decision reasonably well. Such a bug is deeply hidden in some spec, maybe even just an implicit behavior and can&rsquo;t be easily looked up in any documentation of a library. I could have easily created such a bug myself and solving it makes me feel like I could grow as a software engineer simply by fixing it. Unfortunately, cool bugs are rare!</p><p>Here&rsquo;s a quick list of all the awesome tools that were touched in this journey:</p><ul><li><code>netcat</code> (<code>nc</code>)</li><li><code>gstreamer</code> (<code>gst-launch</code>)</li><li><code>ss</code> (or <code>netstat</code> / <code>awk</code> for MacOS)</li></ul><p>Thank you for having a look and stepping through it with me!</p><p>And thank you, Mihail Georgescu & Dominik Manser, for feedback and proof reading this blog post!</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/frontend>frontend</a></li><li><a href=/tags/react>react</a></li><li><a href=/tags/video-streaming>video streaming</a></li><li><a href=/tags/mjpeg>mjpeg</a></li><li><a href=/tags/observability>observability</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/whilenot-dev title=GitHub><i data-feather=github></i></a></div><div class=footer-info>2022 @ Florian Gutzwiller | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>